{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar core_1 = require(\"@angular/core\");\n\nvar forms_1 = require(\"@angular/forms\");\n\nvar platform_browser_1 = require(\"@angular/platform-browser\");\n\nvar textMaskCore_1 = require(\"text-mask-core/dist/textMaskCore\");\n\nvar ɵngcc0 = require('@angular/core');\n\nvar TextMaskConfig =\n/** @class */\nfunction () {\n  function TextMaskConfig() {}\n\n  return TextMaskConfig;\n}();\n\nexports.TextMaskConfig = TextMaskConfig;\nexports.MASKEDINPUT_VALUE_ACCESSOR = {\n  provide: forms_1.NG_VALUE_ACCESSOR,\n  useExisting: core_1.forwardRef(function () {\n    return MaskedInputDirective;\n  }),\n  multi: true\n};\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\n\nfunction _isAndroid() {\n  var userAgent = platform_browser_1.ɵgetDOM() ? platform_browser_1.ɵgetDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\n\nvar MaskedInputDirective =\n/** @class */\nfunction () {\n  function MaskedInputDirective(_renderer, _elementRef, _compositionMode) {\n    this._renderer = _renderer;\n    this._elementRef = _elementRef;\n    this._compositionMode = _compositionMode;\n    this.textMaskConfig = {\n      mask: [],\n      guide: true,\n      placeholderChar: '_',\n      pipe: undefined,\n      keepCharPositions: false\n    };\n\n    this.onChange = function (_) {};\n\n    this.onTouched = function () {};\n    /** Whether the user is creating a composition string (IME events). */\n\n\n    this._composing = false;\n\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n\n  MaskedInputDirective.prototype.ngOnChanges = function (changes) {\n    this._setupMask(true);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  };\n\n  MaskedInputDirective.prototype.writeValue = function (value) {\n    this._setupMask(); // set the initial value for cases where the mask is disabled\n\n\n    var normalizedValue = value == null ? '' : value;\n\n    this._renderer.setProperty(this.inputElement, 'value', normalizedValue);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value);\n    }\n  };\n\n  MaskedInputDirective.prototype.registerOnChange = function (fn) {\n    this.onChange = fn;\n  };\n\n  MaskedInputDirective.prototype.registerOnTouched = function (fn) {\n    this.onTouched = fn;\n  };\n\n  MaskedInputDirective.prototype.setDisabledState = function (isDisabled) {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  };\n\n  MaskedInputDirective.prototype._handleInput = function (value) {\n    if (!this._compositionMode || this._compositionMode && !this._composing) {\n      this._setupMask();\n\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value); // get the updated value\n\n        value = this.inputElement.value;\n        this.onChange(value);\n      }\n    }\n  };\n\n  MaskedInputDirective.prototype._setupMask = function (create) {\n    if (create === void 0) {\n      create = false;\n    }\n\n    if (!this.inputElement) {\n      if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this._elementRef.nativeElement;\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];\n      }\n    }\n\n    if (this.inputElement && create) {\n      this.textMaskInputElement = textMaskCore_1.createTextMaskInputElement(Object.assign({\n        inputElement: this.inputElement\n      }, this.textMaskConfig));\n    }\n  };\n\n  MaskedInputDirective.prototype._compositionStart = function () {\n    this._composing = true;\n  };\n\n  MaskedInputDirective.prototype._compositionEnd = function (value) {\n    this._composing = false;\n    this._compositionMode && this._handleInput(value);\n  };\n  /** @nocollapse */\n\n\n  MaskedInputDirective.ctorParameters = function () {\n    return [{\n      type: core_1.Renderer2\n    }, {\n      type: core_1.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: core_1.Optional\n      }, {\n        type: core_1.Inject,\n        args: [forms_1.COMPOSITION_BUFFER_MODE]\n      }]\n    }];\n  };\n\n  MaskedInputDirective.propDecorators = {\n    'textMaskConfig': [{\n      type: core_1.Input,\n      args: ['textMask']\n    }]\n  };\n\n  MaskedInputDirective.ɵfac = function MaskedInputDirective_Factory(t) {\n    return new (t || MaskedInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forms_1.COMPOSITION_BUFFER_MODE, 8));\n  };\n\n  MaskedInputDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MaskedInputDirective,\n    selectors: [[\"\", \"textMask\", \"\"]],\n    hostBindings: function MaskedInputDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function MaskedInputDirective_input_HostBindingHandler($event) {\n          return ctx._handleInput($event.target.value);\n        })(\"blur\", function MaskedInputDirective_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        })(\"compositionstart\", function MaskedInputDirective_compositionstart_HostBindingHandler() {\n          return ctx._compositionStart();\n        })(\"compositionend\", function MaskedInputDirective_compositionend_HostBindingHandler($event) {\n          return ctx._compositionEnd($event.target.value);\n        });\n      }\n    },\n    inputs: {\n      textMaskConfig: [\"textMask\", \"textMaskConfig\"]\n    },\n    exportAs: [\"textMask\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([exports.MASKEDINPUT_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MaskedInputDirective;\n}();\n\nexports.MaskedInputDirective = MaskedInputDirective;\n\nvar TextMaskModule =\n/** @class */\nfunction () {\n  function TextMaskModule() {}\n  /** @nocollapse */\n\n\n  TextMaskModule.ctorParameters = function () {\n    return [];\n  };\n\n  TextMaskModule.ɵfac = function TextMaskModule_Factory(t) {\n    return new (t || TextMaskModule)();\n  };\n\n  TextMaskModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TextMaskModule\n  });\n  TextMaskModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextMaskModule, {\n      declarations: [MaskedInputDirective],\n      exports: [MaskedInputDirective]\n    });\n  })();\n\n  return TextMaskModule;\n}();\n\nexports.TextMaskModule = TextMaskModule;\n\nvar textMaskCore_2 = require(\"text-mask-core/dist/textMaskCore\");\n\nexports.conformToMask = textMaskCore_2.conformToMask; //# sourceMappingURL=angular2TextMask.js.map","map":null,"metadata":{},"sourceType":"script"}